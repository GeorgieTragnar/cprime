// Comprehensive namespace nesting test for Type and Function Registry validation
// Tests various levels of nesting, cross-namespace references, and edge cases

// === Level 1: Simple Global Types and Functions ===
class GlobalClass {
    int member_var;
    
    void global_method() {
        member_var = 42;
    }
};

struct GlobalStruct {
    float x;
    float y;
};

void global_function(int param) {
    GlobalClass obj;
    GlobalStruct point;
}

// === Level 2: Single Level Namespaces ===
namespace Graphics {
    class Renderer {
        int width;
        int height;
        
        void render() {
            width = 1920;
            height = 1080;
        }
    };
    
    struct Point2D {
        float x;
        float y;
    };
    
    void draw_point(Point2D p) {
        // Function in same namespace using local type
        Renderer r;
        r.render();
    }
    
    void use_global_type() {
        // Function in namespace using global type
        GlobalClass global_obj;
        global_function(100);
    }
}

namespace Math {
    struct Vector3 {
        float x;
        float y; 
        float z;
    };
    
    class Calculator {
        void add(float a, float b) {
            float result = a + b;
        }
    };
    
    Vector3 normalize(Vector3 v) {
        // Return type and parameter type both local to namespace
        Calculator calc;
        return v;
    }
}

// === Level 3: Two-Level Nested Namespaces ===
namespace Engine {
    class GameObject {
        int id;
        
        void update() {
            id = id + 1;
        }
    };
    
    namespace Rendering {
        class Shader {
            int shader_id;
            
            void compile() {
                shader_id = 999;
            }
        };
        
        class Material {
            Shader* current_shader;  // Reference to type in same nested namespace
            
            void apply() {
                current_shader->compile();
            }
        };
        
        void render_object(GameObject obj) {
            // Function using type from parent namespace
            obj.update();
            Shader s;
            s.compile();
        }
    }
    
    namespace Physics {
        struct RigidBody {
            float mass;
            float velocity;
        };
        
        class Collider {
            RigidBody* body;  // Reference to type in same namespace
            
            void check_collision(GameObject game_obj) {
                // Parameter type from parent namespace
                game_obj.update();
            }
        };
        
        void simulate_physics() {
            RigidBody rb;
            Collider col;
            rb.mass = 1.0;
        }
    }
    
    void engine_function() {
        // Function in parent namespace using nested namespace types
        Rendering::Shader shader;
        Physics::RigidBody body;
        GameObject obj;
    }
}

// === Level 4: Three-Level Nested Namespaces ===
namespace Company {
    namespace Products {
        namespace GameEngine {
            class Core {
                int version;
                
                void initialize() {
                    version = 100;
                }
            };
            
            namespace Graphics {
                class Pipeline {
                    Core* engine_core;  // Reference to type from parent namespace
                    
                    void setup() {
                        engine_core->initialize();
                    }
                };
                
                void render_frame(Core core) {
                    // Using type from 3 levels up
                    Pipeline pipeline;
                    core.initialize();
                }
            }
            
            namespace Audio {
                struct SoundBuffer {
                    int sample_rate;
                    int channels;
                };
                
                class AudioManager {
                    void play_sound(SoundBuffer buffer) {
                        buffer.sample_rate = 44100;
                    }
                };
                
                void process_audio() {
                    SoundBuffer buf;
                    AudioManager manager;
                    Core engine;  // Reference to type from parent namespace
                }
            }
        }
    }
}

// === Level 5: Cross-Namespace Function Calls ===
void test_cross_namespace_calls() {
    // Global function calling into various namespaces
    Graphics::Point2D point;
    Graphics::draw_point(point);
    
    Math::Vector3 vec;
    Math::normalize(vec);
    
    Engine::GameObject obj;
    Engine::Rendering::render_object(obj);
    
    Company::Products::GameEngine::Core core;
    Company::Products::GameEngine::Graphics::render_frame(core);
}

namespace TestNamespace {
    void test_from_namespace() {
        // Namespace function calling across namespaces
        Math::Calculator calc;
        Engine::Physics::RigidBody body;
        Company::Products::GameEngine::Audio::SoundBuffer sound;
        
        // Call functions from various namespaces
        Graphics::use_global_type();
        Engine::engine_function();
        global_function(42);
    }
}

// === Level 6: Function Overloading Across Namespaces ===
void process_data(int value) {
    // Global overload
}

void process_data(float value) {
    // Global overload
}

namespace DataProcessing {
    void process_data(GlobalClass obj) {
        // Namespace overload - different signature
    }
    
    void process_data(Graphics::Point2D point) {
        // Namespace overload with namespaced parameter
    }
    
    namespace Advanced {
        void process_data(Math::Vector3 vec) {
            // Nested namespace overload
        }
        
        void test_overloads() {
            process_data(42);           // Should resolve to global int version
            process_data(3.14);         // Should resolve to global float version
            
            GlobalClass obj;
            process_data(obj);          // Should resolve to parent namespace version
            
            Math::Vector3 v;
            process_data(v);            // Should resolve to local version
        }
    }
}

// === Level 7: Type Dependencies Across Namespaces ===
namespace Dependencies {
    class ServiceA {
        Graphics::Renderer* renderer;  // Dependency on different namespace
        Math::Calculator calc;         // Embedded dependency
        
        void use_services() {
            renderer->render();
            calc.add(1.0, 2.0);
        }
    };
    
    namespace Nested {
        class ServiceB {
            ServiceA* parent_service;   // Dependency on parent namespace
            Engine::GameObject game_obj; // Dependency on different top-level namespace
            
            void complex_operation() {
                parent_service->use_services();
                game_obj.update();
            }
        };
        
        void test_complex_dependencies() {
            ServiceB service;
            Company::Products::GameEngine::Audio::AudioManager audio;
            Engine::Physics::Collider collider;
            
            service.complex_operation();
        }
    }
}

// === Level 8: Edge Cases and Stress Tests ===
namespace EdgeCases {
    // Empty namespace with just declarations
    namespace Empty {
        class EmptyClass;  // Forward declaration only
        void empty_function();  // Declaration only
    }
    
    // Single item namespaces
    namespace SingleType {
        struct OnlyStruct {
            int value;
        };
    }
    
    namespace SingleFunction {
        void only_function() {
            SingleType::OnlyStruct s;
        }
    }
    
    // Namespace with many nested levels
    namespace Level1 {
        namespace Level2 {
            namespace Level3 {
                namespace Level4 {
                    namespace Level5 {
                        class DeepClass {
                            void deep_method() {
                                // Very deep nesting
                            }
                        };
                        
                        void deep_function(DeepClass obj) {
                            obj.deep_method();
                        }
                    }
                }
            }
        }
    }
}

int main() {
    test_cross_namespace_calls();
    TestNamespace::test_from_namespace();
    DataProcessing::Advanced::test_overloads();
    Dependencies::Nested::test_complex_dependencies();
    
    EdgeCases::Level1::Level2::Level3::Level4::Level5::DeepClass deep;
    EdgeCases::Level1::Level2::Level3::Level4::Level5::deep_function(deep);
    
    return 0;
}