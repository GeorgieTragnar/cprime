// COMPREHENSIVE EXEC ALIAS SYSTEM TEST
// Tests: reverse order, multiple specializations, complex instantiation patterns

// ========================================
// SCENARIO 1: Reverse Order Definition
// Specializations defined BEFORE their parent
// ========================================

// Specialization for data_processor (parent not yet defined)
exec data_processor<T> csv_handler<delimiter> {
    string input_file = "data.csv";
    char sep = ',';
    bool has_header = true;
    
    DataReader reader;
    reader.configure(input_file, sep, has_header);
    reader.validate_format();
};

// Another specialization for data_processor (parent still not defined)
exec data_processor<T> json_handler<schema_path> {
    string json_file = "data.json"; 
    string schema = "schema.json";
    bool strict_mode = true;
    
    JsonValidator validator;
    validator.load_schema(schema);
    validator.set_strict(strict_mode);
};

// NOW define the parent (after specializations)
exec data_processor<T> {
    -- Parent Lua script: process any data format
    local content = params[0]  -- Specialization CPrime content
    local format_type = params[1] or "generic"
    
    -- Analyze the specialization to determine processing strategy
    local has_csv = string.find(content, "csv") ~= nil
    local has_json = string.find(content, "json") ~= nil
    local var_count = 0
    
    -- Count variable declarations
    for _ in string.gmatch(content, "%w+%s+%w+%s*=") do
        var_count = var_count + 1
    end
    
    local processor_code = "// Generated data processor\n"
    processor_code = processor_code .. "class DataProcessor {\n"
    processor_code = processor_code .. "    static const int DETECTED_VARS = " .. var_count .. ";\n"
    
    if has_csv then
        processor_code = processor_code .. "    // CSV processing detected\n"
        processor_code = processor_code .. "    CsvProcessor processor;\n"
    elseif has_json then
        processor_code = processor_code .. "    // JSON processing detected\n"
        processor_code = processor_code .. "    JsonProcessor processor;\n"
    else
        processor_code = processor_code .. "    // Generic processing\n"
        processor_code = processor_code .. "    GenericProcessor processor;\n"
    end
    
    processor_code = processor_code .. "};"
    
    return processor_code
};

// ========================================
// SCENARIO 2: Multiple Specializations with Single Parent
// ========================================

// Parent first this time
exec validator<T> {
    -- Universal validation engine
    local spec_content = params[0]
    local validation_type = params[1] or "standard"
    
    -- Detect validation patterns
    local has_email = string.find(spec_content, "email") ~= nil
    local has_phone = string.find(spec_content, "phone") ~= nil  
    local has_age = string.find(spec_content, "age") ~= nil
    local has_required = string.find(spec_content, "required") ~= nil
    
    local validator_class = "class ValidationEngine {\n"
    validator_class = validator_class .. "public:\n"
    
    if has_email then
        validator_class = validator_class .. "    bool validate_email(const string& email);\n"
    end
    if has_phone then
        validator_class = validator_class .. "    bool validate_phone(const string& phone);\n"
    end
    if has_age then
        validator_class = validator_class .. "    bool validate_age(int age);\n"
    end
    if has_required then
        validator_class = validator_class .. "    bool check_required_fields();\n"
    end
    
    validator_class = validator_class .. "};"
    
    return validator_class
};

// Multiple specializations for the same parent
exec validator<T> email_validator<domain_whitelist> {
    string email_field = "user_email";
    bool required = true;
    string domain_pattern = "@company.com";
    
    EmailChecker checker;
    checker.set_required(required);
    checker.add_domain_filter(domain_pattern);
};

exec validator<T> phone_validator<country_code> {
    string phone_field = "contact_phone";
    bool required = false;
    string format = "+1-XXX-XXX-XXXX";
    
    PhoneFormatter formatter;
    formatter.set_country_code("+1");
    formatter.validate_format(format);
};

exec validator<T> age_validator<min_max> {
    int age_field = 0;
    bool required = true;
    int min_age = 18;
    int max_age = 120;
    
    AgeChecker checker;
    checker.set_bounds(min_age, max_age);
    checker.enforce_required(required);
};

// ========================================  
// SCENARIO 3: Complex Instantiation Patterns
// ========================================

// Usage with different instantiation styles
csv_handler<"|"> pipe_csv_processor;          // Pipe-delimited CSV
csv_handler<"\t"> tab_csv_processor;          // Tab-delimited CSV
json_handler<"strict.json"> strict_json;      // Strict JSON validation
json_handler<"loose.json"> loose_json;        // Loose JSON validation

// Chained instantiations
email_validator<"@company.com"> company_email;
phone_validator<"+1"> us_phone;
phone_validator<"+44"> uk_phone;
age_validator<"18-65"> working_age;
age_validator<"0-17"> minor_age;

// ========================================
// SCENARIO 4: Nested Template Scenarios  
// ========================================

exec container<T> {
    -- Smart container generator
    local content = params[0]
    local container_type = params[1] or "vector"
    
    -- Analyze what's being stored
    local has_strings = string.find(content, "string") ~= nil
    local has_ints = string.find(content, "int") ~= nil
    local has_custom = string.find(content, "class") ~= nil
    
    local container_code = "template<typename T>\n"
    container_code = container_code .. "class SmartContainer {\n"
    container_code = container_code .. "private:\n"
    container_code = container_code .. "    std::vector<T> data;\n"
    container_code = container_code .. "public:\n"
    
    if has_strings then
        container_code = container_code .. "    // String-optimized operations\n"
        container_code = container_code .. "    void add_string(const T& str);\n"
    end
    if has_ints then
        container_code = container_code .. "    // Integer-optimized operations\n"  
        container_code = container_code .. "    void add_number(const T& num);\n"
    end
    if has_custom then
        container_code = container_code .. "    // Custom class operations\n"
        container_code = container_code .. "    void add_object(const T& obj);\n"
    end
    
    container_code = container_code .. "};"
    
    return container_code
};

exec container<T> string_container<encoding> {
    string default_encoding = "utf-8";
    bool case_sensitive = true;
    int max_length = 1000;
    
    StringManager manager;
    manager.set_encoding(default_encoding);
    manager.set_case_sensitivity(case_sensitive);
};

exec container<T> int_container<range> {
    int min_value = 0;
    int max_value = 100;
    bool allow_negative = false;
    
    IntegerValidator validator;
    validator.set_range(min_value, max_value);
    validator.allow_negatives(allow_negative);
};

// Complex nested instantiations
string_container<"utf-16"> unicode_strings;
int_container<"-1000:1000"> signed_ints;
string_container<"ascii"> simple_strings;

// ========================================
// SCENARIO 5: Regular Code Mixed With Exec System
// ========================================

// Normal CPrime classes
class DataFile {
    string filename;
    bool is_open;
public:
    DataFile(const string& name) : filename(name), is_open(false) {}
    bool open();
    void close();
};

// Normal functions
int calculate_checksum(const string& data) {
    int sum = 0;
    for (char c : data) {
        sum += static_cast<int>(c);
    }
    return sum;
}

// Main function to test everything
int main() {
    // Test the generated processors
    pipe_csv_processor.process_file("data.txt");
    strict_json.validate_input("config.json");
    
    // Test validators
    company_email.validate("user@company.com");
    us_phone.validate("+1-555-123-4567");
    working_age.validate(25);
    
    // Test containers
    unicode_strings.add("Hello 世界");
    signed_ints.add(-500);
    
    // Regular code
    DataFile config("settings.dat");
    config.open();
    int checksum = calculate_checksum("test data");
    config.close();
    
    return 0;
}