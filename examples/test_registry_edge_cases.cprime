// Registry edge cases and stress testing
// Tests unusual scenarios, boundary conditions, and registry resilience

// === Edge Case 1: Forward Declarations and Incomplete Types ===

// Forward declarations at global scope
class ForwardGlobal;
struct ForwardStruct;

namespace ForwardTest {
    // Forward declarations in namespace
    class ForwardInNamespace;
    
    // Use forward declared types
    class UsingForward {
        ForwardGlobal* global_ptr;              // Forward declared global type
        ForwardInNamespace* namespace_ptr;      // Forward declared namespace type
        ForwardStruct* struct_ptr;              // Forward declared global struct
        
        void use_forward_types() {
            // Cannot use methods on forward declared types
            // global_ptr->unknown_method();  // This would be invalid
        }
    };
    
    // Later definition in same namespace
    class ForwardInNamespace {
        int forward_value;
        
        void forward_method() {
            forward_value = 42;
        }
    };
    
    // Function using now-complete type
    void use_complete_type(ForwardInNamespace obj) {
        obj.forward_method();  // Now valid
    }
}

// Complete the global forward declarations
class ForwardGlobal {
    float global_forward_value;
    
    void global_forward_method() {
        global_forward_value = 3.14;
    }
};

struct ForwardStruct {
    int struct_value;
};

// === Edge Case 2: Empty and Minimal Constructs ===

namespace Empty {
    // Completely empty namespace - should still be registered
}

namespace MinimalTypes {
    // Minimal class
    class MinimalClass {
        // No members - valid but empty
    };
    
    // Minimal struct  
    struct MinimalStruct {
        // No members - valid but empty
    };
    
    // Minimal function
    void minimal_function() {
        // No body content - valid but empty
    }
    
    // Function with minimal parameter
    void use_minimal(MinimalClass obj) {
        // Parameter usage
        MinimalClass local = obj;
    }
}

namespace SingleMember {
    class SingleMemberClass {
        int only_member;  // Exactly one member
    };
    
    void single_parameter_function(int param) {
        // Exactly one parameter
        SingleMemberClass obj;
        obj.only_member = param;
    }
}

// === Edge Case 3: Very Deep Namespace Nesting ===

namespace L1 {
    class L1Class { int l1_val; };
    
    namespace L2 {
        class L2Class { int l2_val; };
        
        namespace L3 {
            class L3Class { int l3_val; };
            
            namespace L4 {
                class L4Class { int l4_val; };
                
                namespace L5 {
                    class L5Class { int l5_val; };
                    
                    namespace L6 {
                        class L6Class { int l6_val; };
                        
                        namespace L7 {
                            class L7Class { int l7_val; };
                            
                            namespace L8 {
                                class L8Class { int l8_val; };
                                
                                // Very deep function referencing all levels
                                void deep_function() {
                                    L1Class l1;      // 7 levels up
                                    L2Class l2;      // 6 levels up
                                    L3Class l3;      // 5 levels up
                                    L4Class l4;      // 4 levels up
                                    L5Class l5;      // 3 levels up
                                    L6Class l6;      // 2 levels up
                                    L7Class l7;      // 1 level up
                                    L8Class l8;      // Same level
                                }
                                
                                // Function with complex qualified name resolution
                                void complex_qualified_access() {
                                    L1::L2::L3::L4::L5::L6::L7::L8::L8Class fully_qualified;
                                    L7::L8Class partial_qualified;
                                    L8Class direct;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// === Edge Case 4: Large Numbers of Overloads ===

namespace ManyOverloads {
    // Many overloads of same function name
    void overloaded_function(int param) { }
    void overloaded_function(float param) { }
    void overloaded_function(double param) { }
    void overloaded_function(char param) { }
    void overloaded_function(bool param) { }
    
    // Overloads with multiple parameters
    void multi_param_overloads(int a, int b) { }
    void multi_param_overloads(float a, float b) { }
    void multi_param_overloads(int a, float b) { }
    void multi_param_overloads(float a, int b) { }
    
    // Overloads with class parameters
    class OverloadClass { int val; };
    
    void class_overloads(OverloadClass obj) { }
    void class_overloads(OverloadClass* ptr) { }
    void class_overloads(int val, OverloadClass obj) { }
    void class_overloads(OverloadClass obj, int val) { }
    
    // Test overload resolution
    void test_overload_resolution() {
        overloaded_function(42);       // int version
        overloaded_function(3.14f);    // float version
        overloaded_function(3.14);     // double version
        overloaded_function('a');      // char version
        overloaded_function(true);     // bool version
        
        multi_param_overloads(1, 2);
        multi_param_overloads(1.0f, 2.0f);
        multi_param_overloads(1, 2.0f);
        multi_param_overloads(1.0f, 2);
        
        OverloadClass obj;
        class_overloads(obj);
        class_overloads(&obj);
        class_overloads(42, obj);
        class_overloads(obj, 42);
    }
}

// === Edge Case 5: Complex Type Dependencies ===

namespace CircularTest {
    // Forward declarations to enable circular dependencies
    class ClassA;
    class ClassB;
    
    class ClassA {
        ClassB* b_ptr;  // Circular reference
        
        void use_b();  // Forward declaration
    };
    
    class ClassB {
        ClassA* a_ptr;  // Circular reference
        
        void use_a() {
            a_ptr->use_b();  // Call to A's method
        }
    };
    
    void ClassA::use_b() {
        b_ptr->use_a();  // Call to B's method
    }
    
    // Function using both types
    void test_circular(ClassA a, ClassB b) {
        a.use_b();
        b.use_a();
    }
}

namespace ChainDependency {
    class Base {
        int base_val;
    };
    
    class Level1 {
        Base base_ref;
        
        void use_base() {
            base_ref.base_val = 1;
        }
    };
    
    class Level2 {
        Level1 level1_ref;
        
        void use_level1() {
            level1_ref.use_base();
        }
    };
    
    class Level3 {
        Level2 level2_ref;
        
        void use_level2() {
            level2_ref.use_level1();
        }
    };
    
    // Chain of dependencies: Level3 -> Level2 -> Level1 -> Base
    void test_chain() {
        Level3 l3;
        l3.use_level2();
    }
}

// === Edge Case 6: Namespace Resolution Stress Test ===

namespace StressTest {
    // Many types with similar names
    class TestClass1 { int val1; };
    class TestClass2 { int val2; };
    class TestClass3 { int val3; };
    class TestClass4 { int val4; };
    class TestClass5 { int val5; };
    
    // Many functions with similar names
    void test_func1(TestClass1 p) { }
    void test_func2(TestClass2 p) { }
    void test_func3(TestClass3 p) { }
    void test_func4(TestClass4 p) { }
    void test_func5(TestClass5 p) { }
    
    namespace Sub1 {
        class SubTestClass1 { TestClass1 ref1; };
        void sub_func1(SubTestClass1 p) { }
        
        namespace SubSub1 {
            class SubSubTestClass1 { SubTestClass1 ref1; };
            void subsub_func1(SubSubTestClass1 p) { }
        }
    }
    
    namespace Sub2 {
        class SubTestClass2 { TestClass2 ref2; };
        void sub_func2(SubTestClass2 p) { }
        
        namespace SubSub2 {
            class SubSubTestClass2 { SubTestClass2 ref2; };
            void subsub_func2(SubSubTestClass2 p) { }
        }
    }
    
    // Complex cross-references
    void complex_cross_refs() {
        TestClass1 t1;
        TestClass2 t2;
        Sub1::SubTestClass1 st1;
        Sub2::SubTestClass2 st2;
        Sub1::SubSub1::SubSubTestClass1 sst1;
        Sub2::SubSub2::SubSubTestClass2 sst2;
        
        test_func1(t1);
        test_func2(t2);
        Sub1::sub_func1(st1);
        Sub2::sub_func2(st2);
        Sub1::SubSub1::subsub_func1(sst1);
        Sub2::SubSub2::subsub_func2(sst2);
    }
}

// === Edge Case 7: Registry Boundary Testing ===

namespace BoundaryTest {
    // Test with many similar but distinct names
    class TypeA { };
    class TypeAA { };
    class TypeAAA { };
    class Type_A { };
    class Type_AA { };
    
    void funcA() { }
    void funcAA() { }
    void funcAAA() { }
    void func_A() { }
    void func_AA() { }
    
    // Test name collision detection
    namespace Sub {
        // These should all be allowed - different from parent namespace
        class SubTypeA { TypeA ref; };      // Reference to parent is OK
        class SubTypeAA { TypeAA ref; };
        
        void sub_funcA(SubTypeA p) { }
        void sub_funcAA(SubTypeAA p) { }
        
        // These would be invalid due to shadowing (commented out)
        // class TypeA { };  // Would shadow BoundaryTest::TypeA
        // void funcA() { }  // Would shadow BoundaryTest::funcA
    }
}

// === Main Test Function ===
int main() {
    // Test forward declarations
    ForwardGlobal global_obj;
    ForwardTest::ForwardInNamespace namespace_obj;
    ForwardTest::use_complete_type(namespace_obj);
    
    // Test minimal constructs
    MinimalTypes::MinimalClass minimal;
    MinimalTypes::minimal_function();
    SingleMember::single_parameter_function(42);
    
    // Test deep nesting
    L1::L2::L3::L4::L5::L6::L7::L8::deep_function();
    L1::L2::L3::L4::L5::L6::L7::L8::complex_qualified_access();
    
    // Test many overloads
    ManyOverloads::test_overload_resolution();
    
    // Test circular dependencies
    CircularTest::ClassA a;
    CircularTest::ClassB b;
    CircularTest::test_circular(a, b);
    
    // Test dependency chains
    ChainDependency::test_chain();
    
    // Test stress scenarios
    StressTest::complex_cross_refs();
    
    // Test boundary conditions
    BoundaryTest::Sub::sub_funcA(BoundaryTest::Sub::SubTypeA());
    
    return 0;
}